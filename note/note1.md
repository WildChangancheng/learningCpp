# C语言复习

[TOC]

## 1 基础

### 1.1 关于C语言

1972年，贝尔实验室的Dennis Ritch和Ken Thompson在开发UNIX操作系统时设计了C语言。

总体上来说，C语言融合了计算机科学理论和实践的控制特性，面向过程，是高效的语言并且拥有不错的可移植性，强大而灵活。

### 1.2 编写与编译

使用C语言工作实，整体可以分为：

1. 定义程序的目标
2. 设计程序
3. 编写代码
4. 编译
5. 运行程序
6. 测试和调试程序
7. 维护和修改程序

七步。编译这一步是把源代码转换成可执行代码的程序的步骤。不同计算机使用不同的机器语言方案，C编译器负责吧C语言代码翻译成特定的机器语言。

总体上来说，多思考多规划再动手编写代码总是好的。要养成先动脑后动手的习惯。

大多数时候，我们要求一个c语言文件的基本名basename合法、扩展名extension为.c或者.h。有些特殊的系统，比如MS-DOS要求basename不超过8个char，有些UNIX系统则限制整个文件名（包括extension）都不超过14个char。

当然，现在的Linux、Windows和MacOS都允许使用长文件名。

C语言编译的基本过程是，编译器把源代码转换成中间代码后，用链接器把中间代码和其它代码合并，最终生成可执行文件。

这里用到了分而治之的思想，所以也可以独立编译单独的模块，稍后再用链接器合并已经编译好的模块或者把已经编写好的程序和预编译的库代码合并。

中间文件有很多种形式，我们在这里探讨最普遍的一种形式，也就是

- 把源代码转换成机器语言代码并把结果放在目标代码文件中。
- 然后补全原本缺失的启动代码startup code。启动代码充当程序和操作系统之间的接口。例如，可以在MS Windows或Linux系统下运行IBM PC兼容机，因为使用的硬件相同，所以目标代码相同。但是Linux和Windows系统使用的启动代码不同，因为系统处理程序的方式不同。
- 现在目标代码还缺少库函数，链接器会将目标代码、标准启动代码和库代码和拽到一个文件里，也就是可执行文件。对于库代码，链接器只会把程序中需要用到的库函数代码提取出来。

GNU项目开始于1987年，是一个开发大量免费UNIX软件的集合，其中包括GCC C语言编译器。用gcc命令就可以调用GCC编译器，许多使用GCC的系统都是用cc作为gcc的别称。

此外，LLVM项目成为cc的另一个替代品，该项目是与编译器相关的开源软件集合，其中Clang编译器可以通过clang调用。2012年后Clang几位FreeBSD的默认C语言编译器。

gcc可以通过`-std=c99`之类的参数调用不同的C语言标准。

Windows系统上Cygwin尽可能模拟Linux命令行环境，进行编译、MinGW在Windows的命令提示模式中运行。Borland的C++编译器也是一个选择，支持到C90.

C编译器生成的中间目标代码文件的扩展名通常是.obj。不同于Unix编译器，这些编译器完成编译后通常会保留中间文件（比如.asm扩展名的汇编语言文件）。

另外，集成开发环境IDE也是一个不错的选择。

在程序执行完毕后，执行程序的窗口立即消
失。如果不希望出现这种情况，可以让程序暂停，直到按下Enter键，窗口
才消失。要实现这种效果，可以在程序的最后（return这行代码之前）添加
下面一行代码：
getchar();
该行读取一次键的按下，所以程序在用户按下Enter键之前会暂停。有
时根据程序的需要，可能还需要一个击键等待。这种情况下，必须用两次
getchar()：
getchar();
getchar();

## 1.3 再写个Hello, world吧

```c
// chapter1 eg1.c
#include <stdio.h>

int main() {
    printf("Hello, world\n");
    return 0;
}
```

\#include 指令和头文件

这是程序的预处理器指令preprocessor directive，头文件包含编译器创建最终可执行程序要用到的信息，比如某些常量或者函数名之类的东西。总之，头文件帮助编译器把程序正确组合在一起。 ANSI/ISO规定了C语言编译器必须提供的头文件。

C语言中，一定需要有声明declaration才可以使用某一个变量，告诉编译器会出现什么变量名，这个变量是什么类型。标识符（变量、函数或者其他实体的名称）也有一定的法则。

旧版的C语言要求变量声明必须在块的顶部，其他语句不能在任何声明的前面。C99和C11以后则变得灵活了很多。不过，首次使用变量之前一定要声明。C99和C11后允许更长的变量名，但是不要超过63个字符（另外，外部标识符只允许使用31个字符）

合法的标识符可以包括大小写字母、数字和下划线，其中数字不能用作开头。另外，操作系统和C库经常使用一个或两个下划线开始的标识符，所以自己的程序中尽量不要这么用比较好。标准标签都以一个或两个下划线字符开始，这样的标识符都是保留着的。另外，C语言的标识符是大小写敏感的。

## 1.4 定义一个函数

在不准备一开始写出整个程序的时候，可以先写出函数原型（函数原型相当于声明函数，要加`分号;`完成整个语句。函数原型在C90加入，导致旧的编译器可能无法识别。函数原型是一种生命形式，告诉编译器正在使用某函数，所以函数原型也叫function declaration。

C语言标准其实建议腰围程序中用到的所有函数都提供函数原型，标准include文件为标准库函数提供函数原型。

试试写一个bmi的计算程序。

```c
// chapter2 eg2.c
#include <stdio.h>

float bmi_caculator(float height, float weight) {
    return weight / height / height;
}
int main(void) {
    float result = bmi_caculator(1.7, 65);
    printf("%f\n", result);
    return 0;
}
```

## 1.5 一些输入输出

可以阅读<https://c.biancheng.net/view/cttgz7l.html>这个网页，会有详尽的讲解。

缓冲区类似于一个队列结构，他会记录你在控制台中输入的所有键盘响应（包括空格和回车等），既然是队列，那就满足FIFO的顺序（First In， Firs Out，所谓的先入先出）。

getchar()只能读出字符型，但形式比较简单，因此常用来清洗缓冲区。接下来就是scanf()函数，它分为两部分scanf("控制符部分"，&参数列表)：第一部分为控制符部分，这里和printf的控制符部分是相同的，例如你想获取一个整型数据就要使用“%d”、获取一个字符数据便使用“%c”。

scanf遇到第一个空白（比如空格、制表符、换行符）就会停止输入。所以一般而言，scanf只会读取字符串中的一个单词，而不是一整句。C语言还有专门的输入函数，比如fgets，用于读取字符串。这些会在后面体积。
## 1.6 变量和常量数据

有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为常量（constant）。其他数据类型在程序运行期间可能会改变或被赋值，这些称为变量（variable）。在示例程序中，weight 是一个变量，14.5833 是一个常量。

对于字面量，C语言编译器一般直接通过用户书写的形式进行类型识别，例如42是整形，42.100是浮点型。但是，对变量而言，要在声明时指定其类型（也就是说需要进行声明）。

对于整型而言，C90新增了signed关键字用于提供基本整数类型。\_Bool类型表示布尔值true或false。\_complex和\Imaginary表示复数和虚数。通过这些关键字创建的类型可以按计算机的存储方式氛围整数类型和浮点数类型。

bit是最小的存储单元、在此之上有更大的byte类型（对于几乎所有机器，我们都规定1Byte=8bits）、word是涉及计算机时给定的自然存储单位。计算机的字越大，数据转移就越快，允许访问的内存也就越多。最初的计算机1word只有1bit，而现在已经在用64位计算机了。

再复习一下，计算机中的数字是按补码存储的，对于负数都要取反+1，从而形成类似环的结构。

### 整数与浮点数

___

浮点数与数学中实数的概念差不多。2.75、3.16E7、7.00 和 2e-8 都是浮点数。计算机把浮点数分成小
数部分和指数部分来表示，而且分开储存这两部分。因此，虽然7.00和7在数值上相同，但是它们的储存方式不同。在十进制下，可以把7.0写成0.7E1。这里，0.7是小数部分，1是指数部分。

声明declaration是指出类型和变量名；初始化initialize是赋初识值。C语言的初始化可以在声明的时候完成，只需要再变量名后面直接加上赋值运算符和值就好。

C语言中0x或0X前缀表示十六进制值、0表示八进制、0b和0B表示二进制。

再字面量结尾加上l或者L就可以强制使用long类型存储哪怕很小的数（最好用大写的L，因为小写的l和1很像）

### char

通常来说，65表示'A'。

转义字符\a警报、\b退格、\f换页、\n换行、\r回车（回到最初）、\t水平制表符、\v垂直制表符、\0oo转换八进制、\xhh转换十六进制

### _Bool类型

C99中才正式加入再C语言中，用于表示布尔类型，也就是逻辑值true和false，因为C语言用1表示true，0表示false。所以_Bool类型实际上也是一种整数类型，但原则上它紧紧表示占用1bit存储空间，因为对0和1而言，1位的存储空间已经足够了。

### 关于可移植类型

C语言为现有类型创建了更多类型名。这些新的类型名定义在stdint.h头文件中。

### 浮点类型

这里比较特殊，浮点类型的表示方法类似于科学计数法，可以表示非常大和非常小的数。程序将科学计数法转换成指数计数法。

float有至少6位有效数字。通常，系统储存一个浮点数要占用32位，其中8位用于表示指数的值和符号，剩下24位用于表示非指数部分（也叫尾数或有效数）及其符号。

更进一步地，C语言还有double类型，也就是双精度浮点型，至少能表示10位有效数字，通常会占用64位。不同系统的处理策略不同，但无论什么系统，double类型通常都有至少13位有效数字，精准度更高。

此外，还有long double，从而保证更高的精度要求。

___

浮点型字面量也可以写成-1.56E+12之类的样子，默认情况下，编译器假定浮点型常量是double类型的精度。

___

打印long double类型要使用%Lf、%Le或%La。

有另一个特殊的浮点值NaN（not a number的缩写）

### 复数和虚数

也许你会感觉_Complex和_Imaginary很难xp，那就导入complex.h头文件就好了。为什么要专门定义一个头文件？就是为了不和很多程序员自己设计的程序不冲突。

### sizeof

sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型。一些不支持C99和C11的编译器可用%u或%lu代替%zd。

## 1.7 关于赋值等

C语言的类型匹配非常不严格，甚至允许二次初始化。把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与
变量匹配的类型，这也许会导致信息的丢失。

编译器把浮点数转换成整数时，会直接丢弃（截断）小数部分，而不进行四舍五入、用float接收一个比较精细的数可能会损失一定精度。

许多程序员和公司内部都有系统化的命名约定，在变量名中体现其类型。如用 _前缀表示 int类型，us_前缀表示unsigned short类型

## 1.8 关于刷新缓存区

printf()何时把输出发送到屏幕上？最初，printf()语句把输出发送到一个叫作缓冲区（buffer）的中间存储区域，然后缓冲区中的内容再不断被发送到屏幕上。C 标准明确规定在缓存区充满或者遇到换行字符、需要输入的时候刷新缓存区。

旧式编译器遇到scanf()也不会强行刷新缓冲区，这就需要在程序中手动刷新缓冲区。

## 2 字符串和格式化输入/输出

### 2.1 char类型数组和null字符

C语言没有专门开发类似Python的str之类的字符串类型。字符串被存储在char类型的数组中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符。最终用一个空字符null character（也就是\0）结尾，C语言用它标记字符串的结束。空字符不是数字0，而是专门的\0，是一个非打印字符，ASCII码点是0。C语言的字符串一定是用null character结尾，所以实际上数组的容量必须至少比带存储字符串中的字符数量多1。例如一个40Bytes的字符串实际上最多只能存储39个char。

数组是同类型数据元素的有序序列。而字符串实际上是特殊类型的数组，如果试着用type hint写的话，也许就是list[str]，当然用C语言来说是array[char]。

接下来试着使用字符串：

第二章的eg1我们试试：

```c
# chapter2 eg1.c
#include <stdio.h>
#define PRAISE "You are an extraordinary being."

int main(void) {
    char name[40];
    printf("Wht's your name? Type in here:");
    scanf("%s", name);
    printf("Hello, %s. %s\n", name, PRAISE);
    return 0;
}
```

在这里咱们就创建了一个很大的内存空间并往里面写入了一个name，用%s格式化输出了一个字符串。你不用亲自把空字符放入字符串末尾，scanf()在读取输入时就已完成了这项工作。同样的，也不用再字符串常量PRAISE结尾添加\0，因为编译器同样完成了这项工作。对于双引号包裹的内容，编译器会自动理解为字符串并加上这些东西的。

### 2.2 strlen和const

strlen函数可以用来计算字符串中的字符长度。strlen包含在头文件string中。

用C预处理器指令#define和const修饰符可以创建常量。在代码中少使用MagicNumber，而是定义为变量、常量并写明，说不清楚的用注释，这是一种美德。

C语言的预处理器define命令其实是一种宏定义。#define TAXRATE 0.015意味着，编译程序时，程序中所有的TAXRATE都会被替换成0.015。这一过程被称为编译时替换（compile-time substitution）。这样定义的常量也称为明示常量。注意，格式中并没有使用`=`符号，所以通用格式是#define Name Value。另外，宏定义末尾不加分号，因为这是一种预处理器处理的替换机制。另外，C语言的传统是用大写表示符号常量，小写表示变量。所以最好用大写保证程序的可读性。虽然不这么做也不影响程序运行，但好的代码风格是很重要的习惯。

另外，还有一个不常用的命名约定，即在名称前带c_或k_前缀来表示量（如，c_level或k_line）。

C90中，新增了一个const key word，用于限定一个变量为只读变量（也就是说不可修改），直接在变量declaration潜加上const关键字即可，实际上const比#define更加灵活，我们会在后面更详细讨论。

### 2.3 再谈printf和scanf

他们用到的%c之类的东西属于其实叫转换说明conversion specification，它们指定了如何把数据转换成可显示的形式，

在%和conversation specification之间可以插入修饰符，修饰基本的转换并加以说明。

- 标记类
  - -、+、空格、#、0
- 数字：最小字段宽度(如果字段不能容纳待打印的内容，系统会自动使用更宽的字段)
- .数字：小数点位数，也就是精度，如有必要，可以使用前导0达到这个位数，
- h、hh、j、l、ll：都是搭配整形使用，用来表示具体的int类型

我们做一个不恰当的例子，利用一下补码的漏洞。

```c
// chapter2 eg2.c
#include <stdio.h>

int main(void) {
    signed int a = -255;
    printf("The number a is: %d\n", a);
    printf("The number a is: %ud\n", a);
    return 0;
}
```

得到输出：

> The number a is: -255
> The number a is: 4294967041d

事实上，printf也有返回值，输出结果是打印字符的个数。如果有输出错误就会返回负值（老版本的编译器可能会返回不同的值）

scanf遇到空白字符就会断行，除了比较特殊地，使用%c时，scanf会读取每个新的char，包括空格（他不会跳过空格）。

如果使用%s 转换说明，scanf()会读取除空白以外的所有字符。如果使用字段宽度，scanf()在字段末尾或第1个空白字符处停止读取。所以，无法利用字段宽度让只有一个%s的scanf()读取多个单词。最后，当scanf()把字符串放进指定数组中时，它会在字符序列的末尾加上'\0'，也就不需要手动添加null character了。

scanf()函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。例如，假设在两个转换说明中添加一个逗号，scanf就会解释为需要读取逗号,前后的数据。

格式字符串中的空白意味着跳过下一个输入项前面的所有空白（任意多个，反正尽管跳过）。我们尝试一下：

```c
// chapter2 eg3.c
#include <stdio.h>

int main(void) {
    int n1, n2, n3, n4;
    printf("\nType in number set1:");
    scanf("%d,%d", &n1, &n2);
    printf("\nType in number set2:");
    scanf("%d, %d", &n3, &n4);

    printf("n1:%d\n", n1);
    printf("n2:%d\n", n2);
    printf("n3:%d\n", n3);
    printf("n4:%d\n", n4);
    return 0;
}
```

输入：

> Type in number set1:1,     2
>
> Type in number set2:3,       4

也会得到：

> n1:1
> n2:2
> n3:3
> n4:4

这是为什么？set1那里没有写空格啊？因为除了%c，其他转换说明都会自动跳过待输入值前面所有的空白。换句话来说，scanf("%d%d", &n, &m)与scanf("%d %d", &n, &m)的行为相同。对于%c而言，在格式字符串中添加一个空格字符会有所不同。如果把%c放在格式字符串中的空格前面，scanf()便会跳过空格，从第1个非空白字符开始读取。也就是说，scanf("%c", &ch)从输入中的第1个字符开始读取，而scanf(" %c", &ch)则从第1个非空白字符开始读取。

再尝试一下：

```c
// chapter2 eg4.c
#include <stdio.h>

int main(void) {
    char c1, c2, c3;
    printf("\nType in character1:");
    scanf("%c", &c1);
    printf("\nType in character2:");
    scanf("%c ", &c2);
    printf("\nType in character3:");
    scanf(" %c", &c3);

    printf("c1:%c\n", c1);
    printf("c2:%c\n", c2);
    printf("c3:%c\n", c3);
    return 0;
}
```

我们输入:

> \[空格\]\[空格\]\[空格\]\[空格\]\[空格\]\[空格\]6\[空格\]\[空格\]\[空格\]\[空格\]\[空格\]\[空格\]6

也就是前后各6个空格，中间是6，结尾也是6

（一次全输入到缓存区了，所以后面几个压根不用输入）

由于c1没有写空格，所以他会把空格读取掉，c2是在%c后写空格，所以会先读一个空格，然后再跳过后面的空格，c3才拥有真正的跳过空白从第一个非空白字符开始读取的功能。

scanf函数返回成功读取的项数，如果没有读取到任何一个项，而且需要读取一个数字但是用户输入非数值字符串时，scanf会返回0。当scanf检测到文件结尾时会返回EOF（也是一个特殊值，定义在stdio.h中）。

#### *修饰符

如果你不想预先指定字段宽度，希望通过程序来指定（比如读取的长度是一个变量的时候）在不确定需要读取多少宽度时，可以用*修饰符，比如：`printf("The number is :%*d:\n", width, number);`

### 2.4 结尾小题

最后做个review吧。写个程序，引导用户输入姓名，并问好。

```c
// chapter2 eg5
#include <stdio.h>

int main(void) {
    char first_name[40];
    char last_name[40];
    printf("Type your name please, in the way first name, last name:");
    scanf("%s , %s", first_name, last_name);
    printf("\nGotta. Hello, %s %s!Hope you enjoy this simaster!\n", first_name, last_name);
    return 0;
}
```

## 3 循环、运算符、表达式与语句

### 3.1 赋值运算

C语言的赋值格式形如：`lvalue = rvalue;`，会把右值赋值给可修改的左值，原本说左值就好，但是后来C语言中加入了const限定符，用const创建的变量不可修改，所以就专门提出了midifiable lvalue这个词，表示可修改的左值。当前标准建议，使用属于 对象定位值object locator value更好一些。

许多其他语言都会回避该程序中的三重赋值，但是C完全没问题。顺序是从右往左，每个赋值表达式的值都是被赋予左值的右值。从而通过一种类似循环的方式完成多元同时赋值。

### 3.2 其他运算符和表达式

#### 运算

+-都好说（-作为一元运算符表示负号，二元运算符表示加法逆运算；+作为一元运算符不会改变运算对象的值或负号，以前的编译器没有考虑这种没用的情况，但是C90开始允许这种操作）。*也没啥好说的，出发运算符比较特殊，浮点数除法的结果是浮点数，而整数除法的结果是整数。整数是没有小数部分的数。这使得5除以3很让人头痛，因为实际结果有小数部分。在C语言中，整数除法结果的小数部分被丢弃，这一过程被称为截断（truncation）。这种隐式转换经常导致问题，所以需要格外注意。

关于负数的截断，C99标准以前，C语言给语言的实现者留有一些空间。一种方法是，舍入过程采用小于或等于浮点数的最大整数。当然，对于3.8而言，处理后的3符合这一描述。但是-3.8 会怎样？该方法建议四舍五入为-4，因为-4 小于-3.8（就是Python的那种）。但是，另一种舍入方法是直接丢弃小数部分。这种方法被称为“趋零截断”，即把-3.8转换成-3。在C99以前不同的实现采用不同的方法。但是C99规定使用趋零截断。所以，应把-3.8转换成-3。

求模运算%：求余数。

递增运算符++increment operator可移植性简单的任务，将其运算对象递增1。前缀模式先递增后取值，后缀模式先取值后自增。同理可知自减运算符--的性质。自增和自减运算符的优先级甚至高于乘除法运算。

#### sizeof运算符和size_t类型

之前我们已经见过sizeof运算符（有时候是当做sizeof函数使用的）。总之，sizeof也可以是运算符，运算对象可以是具体的数据对象（比如用变量名选中特定的变量）也可以是整个类型。如果运算对象是类型（比如float）就一定要用圆括号把他括起来，让他像函数一样。对于普通的变量或者类型，就无所谓了。

C 语言规定，sizeof 返回 size_t 类型的值。这是一个无符号整数类型，也就是前面的size_t类型。

#### 为类型指定别名 - typedef

可以为一个类型创建别名，比如`typedef double real;`就是让double改名叫real的方式。

while循环是只要表达式为true，就始终执行对应的块block。

#### 什么是表达式，什么是语句

表达式expression是运算符和运算对象组成的式子，一些表达式还可以由更基础一些的子表达式subexpression组成。每个表达式都有一个值，要获取这个值必须严格按照运算符优先级规定的顺序执行操作。

例如：

```c
6+(c=3+8)
```

会得到17并且得到值为11的c，类似于Python的海象运算符：

```python
6+(c:=3+8)
```

也会得到c=11并且原式为17.

语句statement是C程序的基本构建块，一条语句相当于一条完整的计算机指令，C语言中的大部分语句都有分号结尾，因此legs = 4只是一个表达式，但是legs = 4;是一个完整的语句。C语言把末尾加上一个分号的表达式都看做是一条语句，即，表达式语句。函数表达式语句会引起函数调用。

#### 副作用side effect

是指对数据对象或者文件的修改。事实上这似乎才是程序的主要目的。但是从C语言的角度看，一个表达式语句的主要目的是对表达式求知，所以使用表达式语句实际上经常在用他们的副作用。类似的，调用printf函数的时候，其实在使用它的副作用——输出，而不是住作用统计显示字符的个数。

#### 序列点sequence point

是程序执行的点。在该点上，所有副作用都在进入下一步之前发生。C语言中语句的分号标记了一个序列点。任何一个完整的表达式结束其实也是一个序列点。

#### 完整表达式full expression

就是指这个表达式不是另一个更大的expression的subexpression。

理解：事实上，序列点就像是一个存档点，直到下一个存档点，所有东西才会确定清算，并等待下一条statement的反应。现在再思考：

```c
y = (4 + x++) + (6 + x++);
```

C语言标准并没有明确规定对子表达式求值后自增还是求完完整表达式后再自增，只知道一个完整表达式是一个序列点，而没有明确规定子表达式，因此要避免写出这样的语句。

#### 复合语句compound statement（块block）

是指有用花括号括起来的一条或者多条语句，也称作块block。整个block其实被视作一条语句，采用相同级别的缩进。

### 3.3 类型转换

#### 自动转换（隐式转换）

通常，在语句和表达式中应该尽量使用类型相同的变量与常量。但是，如果使用混合类型，C语言不会像Pascal那样子直接停下来死掉，而是采用一套规则进行自动类型转换。事实上，这个自动类型转换有一定危险性，尤其是无意间使用了混合类型的时候。

当隐式类型转换出现时，无论是unsigned还是signed的char和short都会自动被转换成int。这种转让会得到更大的类型，所以也被称为类型升级。

设计两种类型的运算，两个值会被分别转换成两种类型的更高级别。整体上，从等级分，从大到小依次是long double, double, float, unsigned long long, long long, unsigned long, long, unsigned int, int。例外的是，unsigned int比long的级别更高（因为很多系统long和int是一样大的）。

发生在赋值语句中时，计算结果会被转换成赋值变量的类型，这个过程可能导致类型升级，也可能导致类型降级demotion。

当作为函数参数传递的时候，char 和short都会被自动转换成int， float被转换成double。特殊的，函数原型会覆盖自动升级（在后面会提到）。

#### 手动转换（显示转换、强制转换）

使用强制类型转换关键字cast，在某个两的前面用圆括号括起来对应的类型名，就会进行转换。例如：

```c
mice = 1.6 + 1.7;
mice = (int)1.6 + (int)1.7;
```

## 4 函数

声明参数就创建了被称为形式参数（formal argument或formal parameter），调用函数的时候实际传入的是实际参数（actual argument或actual parameter）。所以说，实际上传值的时候，函数调用pound(10)实际上是把实参10传递给函数，然后函数把10赋值给形参（变量n）。也就是说，main中的times的值被拷贝给pound中的新变量n。

我们可以说形参是变量，实参是函数调用提供的值，实参被赋给相应的形参。

变量名是函数私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突。也就是说，程序中出现了两个同名的变量，但是程序可以区分它们。

有函数原型时，函数传入的参数会按照函数原型进行类型转换；否则就会按照默认的情况进行自动转换也就是隐士类型转换，这可能导致很多问题。所以再函数调用中要显式使用强制类型转换。

### 4.1 为什么要使用函数

使用函数包装代码片段可以节省编写重复代码的工作，提高程序可读性，让程序更加模块化。许多程序员喜欢把函数看作是根据传入信息（输入）及其生成的值或响应的动作（输出）来定义的“黑盒”。如果不是自己编写函数，根本不用关心黑盒的内部行为。这种观点的优势在于可以着眼程序设计的大局，而从胶着琐碎的细枝末节中抽离出来。所以在动手写代码之前，最好仔细考虑一下函数应该完成什么任务，函数在程序整体里面扮演什么样的关系。

## 5 循环&分支和跳转

从计算机科学的角度来说，一门计算机语言应该提供一下三种形式的程序流：执行语句序列、特定条件下重复执行语句序列（循环）、通过测试决定语句序列（分支）

### 5.1 while、do…while…

测试一下用while语句从1输出到100：

```c
// chapter5 eg1.c
#include <stdio.h>

int main(void) {
    int n = 1;
    while (n < 101) {
        printf("%d\n", n++);
    } 
    return 0;
}
```

事实上，在某些时候也可以给while跟空语句null statement，也就是什么都不写直接加分号，什么也不做。比如：

```c
while (scanf("%d", &num) == 1)
;
```

会直接停在第一个非空白字符或数字的位置，这段代码的逻辑就是一直读取，并返回当前读取进来的参数个数。所以数字会被全部读取，直到读取失败，scanf把失败的字符放回缓冲区，scanf得到的结果是0，故而while的condition是false，循环中断。这样就可以跳过整数输入。

这个分号最好单开一行，让代码醒目一些。另外，加一个comment是最好的。当然，用continue statement也是好的。

通常而言，所有值都被视为true，除了0被视为false。

C99提供了stdbool.h头文件，该头文件让bool成为_Bool的别名。导入后写出的代码就可以和C++兼容，因为C++里bool、true和false都是关键字。可以试一下：

```c
// chapter5 eg2.c
#include <stdio.h>

int main(void) {
    _Bool condition = 1;
    if (condition) printf("节点1触发成功\n");
    condition = 0;
    if (condition) printf("节点2触发成功\n");
    return 0;
}
```

只会触发节点1。

当然，我们换成：

```c
// chapter5 eg2.c
#include <stdio.h>
#include <stdbool.h>

int main(void) {
    bool condition = true;
    if (condition) printf("节点1触发成功\n");
    condition = false;
    if (condition) printf("节点2触发成功\n");
    return 0;
}
```

如果系统不支持_Bool并且也不想导入stdbool.h的话，直接把_Bool换成int就好了（，毕竟本来也没什么特别的。另外可以宏定义`#define true 1`。

另外，我们可以把while循环分成不确定循环indefinite loop和计数循环counting loop，区别在于执行循环之前是否知道要重复执行多少次。比如上面那个数100个数的程序就是计数循环。

do…while是先做后检查。这样一来就会至少执行一次。语法是:

```c
do
statement
while (expression);
```

### for

从z输出到a吧。eg3：

```c
#include <stdio.h>

int main(void) {
    for (char c = 'z'; c >= 'a'; c--) printf("%c ", c);
    printf("\n");
    return 0;
}
```

> z y x w v u t s r q p o n m l k j i h g f e d c b a

总之程序是正常工作的。另外三个expression不需要全部写满，也可以空着。

利用都好运算符，也可以让for-loop变得更有意思一些。另外，逗号表达式的值等于右侧项的值。

我们知道1/2+1/4+…加下去会得到1，用几何级数的知识就可以轻松算出来。那我们试着加10项试试：

```c
// chapter5 eg4.c
#include <stdio.h>

int main(void) {
    double s = 0;
    double a = 0.5;
    for (int i = 1; i<=10; i++) {
        s += a;
        a *= 0.5;
        printf("第%d次：s = %lf\n", i, s);
    }
}
```

> 第1次：s = 0.500000
> 第2次：s = 0.750000
> 第3次：s = 0.875000
> 第4次：s = 0.937500
> 第5次：s = 0.968750
> 第6次：s = 0.984375
> 第7次：s = 0.992188
> 第8次：s = 0.996094
> 第9次：s = 0.998047
> 第10次：s = 0.999023

可以看到，确实符合预期。

### 循环嵌套

试试写一个程序，输出99乘法表。

```c
// chapter5 eg5.c
#include <stdio.h>

int main(void) {
    for (int i = 1; i <= 9; i++) {
        for (int j = i; j<=9; j++) {
            printf("%d * %d = %02d\t", i, j, i*j);
        }
        printf("\n");
    }
}
```

### if、else

还能嵌套出if、 else if、else之类的东西。另外，使用getchar和putchar可以更简单的输入输出char。

### continue与break

没啥说的

### 逻辑运算符 与 条件运算符

与&& 或|| 非!

`a?b:c`相当于Python的`b if a else c`

### switch

用switch…case…default…即可概括。以及对于跳转表，记得加break

## 6 数组

基本声明方式：

```c
keyword(type) name[length];
```

需要注意的是，普通char array和string最大的区别就在于最后有没有\0，有的话就是完整的string了。

用于索引的index叫做下标subscript，也可以叫indice或者偏移量offset。下标必须是整数，而且从0开始计数。实际上就是相对于数组的起点的偏移量，还容易推到数学关系。不过C语言没有Python中类似`for i in lst:`这样方便的索引方式，想要访问元素还是得通过找indice实现。

总之，索引的最后一项是SIZE-1。

程序最好尽量模块化，也就是modularity，也就是把程序分成一些独立的单元，每个单元执行一个任务。这样提高了程序的可读性。

## 7 C语言的流处理

C语言程序处理的是流stream是一个实际输入或输出映射的理想化数据流，这意味着不同属性和不同种类的输入都由属性更统一的流来完成。计算机操作系统要求文件用特定的方式结尾，标识文件的结束。有一种常用方法是在文件末尾放一个特殊的字符标记文件结尾。如今，操作系统使用内嵌的Ctrl+Z字符来标记文件结尾。

无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF(end of file)。通常，在stdio.h中有定义`#define EOF (-1)`。

所以只要用：`while (ch=getchar()) != EOF)`就可以一直读下去，知道把整个文件读完。

### 7.1 重定向

UNIX（运行命令行模式时）、Linux（ditto）和Window命令行提示都能重定向输入、输出。重定向输入让程序使用文件而不是键盘来输入，重定向输出让程序输出至文件而不是屏幕。（换句话来说，平时的printf函数都是输出到屏幕了）。

试试chapter7的eg1:

```c
// chapter7 eg1.c
#include <stdio.h>

int main(void) {
    int ch;
    printf("Text in the file:\n");
    printf("————————————————————————————————\n");
    while ((ch = getchar()) != EOF) putchar(ch);
    printf("\n");
    printf("————————————————————————————————\n");
    return 0;
}
```

不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定义，可直接使用，不必再编写代码假定EOF为某值。事实上，getchar函数实际返回的类型是int，虽然他叫getchar。所以实际上使用getchar是可以读取到定义为-1的EOF的。

使用重定向输入: `eg1.app<eg1.txt`就会得到：

> Text in the file:
> ————————————————————————————————
> This is a sample.
>
> Text in the file is forwarded to the output program.
> ————————————————————————————————

如果我们试着输出一下：

```bash
(eg1.app<eg1.txt)>output.txt
```

就可以看到一个output.txt，记录了应有的输出。这就是重定向后用流输出。如果重定向后的输出对象已经存在，通常会擦除这个文件的内容然后替换成新的内容（也就是说会覆写）。

另外，UNIX、Linux或Windows/DOS 还有>>运算符，该运算符可以把数据添加到现有文件的末尾，而 | 运算符能把一个文件的输出连接到另一个文件的输入。

也就是

- \> 覆盖写入
- \>\> 追加写入
- | 输入转输出

### 7.2 
